!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
CC	Makefile	/^CC = g++$/;"	m
CFLAGS	Makefile	/^CFLAGS = -Wall -O3 -fopenmp -std=c++11$/;"	m
HAS_OPENBLAS	Makefile	/^HAS_OPENBLAS=0$/;"	m
INCLUDES	Makefile	/^INCLUDES = -I. -I.\/mnist\/include -I$(OPEN_BLAS_INC)$/;"	m
LFLAGS	Makefile	/^LFLAGS = -L$(OPEN_BLAS_LIB)$/;"	m
LIBS	Makefile	/^LIBS = -lopenblas$/;"	m
MAIN	Makefile	/^MAIN = autoencoder$/;"	m
OBJS	Makefile	/^OBJS = $(SRCS:.c=.o)$/;"	m
OPEN_BLAS_INC	Makefile	/^OPEN_BLAS_INC=\/home1\/03155\/jliang\/Desktop\/OpenBLAS\/jliang_install\/include$/;"	m
OPEN_BLAS_LIB	Makefile	/^OPEN_BLAS_LIB=\/home1\/03155\/jliang\/Desktop\/OpenBLAS\/jliang_install\/lib$/;"	m
SRCS	Makefile	/^SRCS = main.cpp neural_network.cpp hidden_layer.cpp autoencoder.cpp output_layer.cpp neural_network_cross.cpp auto_hidden_layer.cpp ga.cpp$/;"	m
auto_compute_delta_hidden	auto_hidden_layer.cpp	/^void auto_hidden_layer::auto_compute_delta_hidden(float *delta_curr_layer, float *delta_next_layer, float *output_curr_layer)$/;"	f	class:auto_hidden_layer
auto_compute_delta_output	auto_hidden_layer.cpp	/^void auto_hidden_layer::auto_compute_delta_output(float *delta, float *o, float *t)$/;"	f	class:auto_hidden_layer
auto_hidden_layer	auto_hidden_layer.cpp	/^auto_hidden_layer::auto_hidden_layer(int numInputs, int numHiddenUnits):$/;"	f	class:auto_hidden_layer
auto_squared_loss	auto_hidden_layer.cpp	/^float auto_hidden_layer::auto_squared_loss(float *input, float *output)$/;"	f	class:auto_hidden_layer
auto_updateWeights	auto_hidden_layer.cpp	/^void auto_hidden_layer::auto_updateWeights(float *delta_e, float *o_i, float *delta_d, float *o_e, float learn_rate)$/;"	f	class:auto_hidden_layer
decode	auto_hidden_layer.cpp	/^void auto_hidden_layer::decode(float *input, float *output)$/;"	f	class:auto_hidden_layer
resetBuffer	auto_hidden_layer.cpp	/^void auto_hidden_layer::resetBuffer()$/;"	f	class:auto_hidden_layer
~auto_hidden_layer	auto_hidden_layer.cpp	/^auto_hidden_layer::~auto_hidden_layer()$/;"	f	class:auto_hidden_layer
AUTO_HIDDEN_LAYER	auto_hidden_layer.h	4;"	d
auto_hidden_layer	auto_hidden_layer.h	/^class auto_hidden_layer: public hidden_layer$/;"	c
buffer	auto_hidden_layer.h	/^  float *decode_biases, *buffer;$/;"	m	class:auto_hidden_layer
decode_biases	auto_hidden_layer.h	/^  float *decode_biases, *buffer;$/;"	m	class:auto_hidden_layer
getDecodeBiases	auto_hidden_layer.h	/^  inline float* getDecodeBiases() {$/;"	f	class:auto_hidden_layer
setDecodeBiases	auto_hidden_layer.h	/^  inline void setDecodeBiases(float *newBiases) {$/;"	f	class:auto_hidden_layer
autoencoder	autoencoder.cpp	/^autoencoder::autoencoder(vector<int> preTrainLayerWidths, vector<float> preTrainLayersLearnRates, vector<int> preTrainLayersOuterIter, vector<float> preTrainLayersNoiseLevels, int numInput, int numHidden, int numOutput, float learn_rate):$/;"	f	class:autoencoder
corrupt_gaussian	autoencoder.cpp	/^void autoencoder::corrupt_gaussian(float *input, float *corrupted_input, float sigma, int length)$/;"	f	class:autoencoder
corrupt_masking	autoencoder.cpp	/^void autoencoder::corrupt_masking(float *input, float *corrupted_input, float fraction, int length)$/;"	f	class:autoencoder
deleteO_i	autoencoder.cpp	/^void autoencoder::deleteO_i(float **o_i, int numTrainingImages)$/;"	f	class:autoencoder
fineTune	autoencoder.cpp	/^void autoencoder::fineTune(float **trainingImages, int numTrainingImages, vector<int> &trainLabels)$/;"	f	class:autoencoder
fineTuneNoHidden	autoencoder.cpp	/^void autoencoder::fineTuneNoHidden(float **trainingImages, int numTrainingImages, vector<int> &trainLabels)$/;"	f	class:autoencoder
getInput	autoencoder.cpp	/^void autoencoder::getInput(float *&o_i)$/;"	f	class:autoencoder
getInputK	autoencoder.cpp	/^void autoencoder::getInputK(float *&o_i, int k)$/;"	f	class:autoencoder
normalRandom	autoencoder.cpp	/^inline float normalRandom()$/;"	f
preTrain	autoencoder.cpp	/^void autoencoder::preTrain(float **trainingImages, int numTrainingImages)$/;"	f	class:autoencoder
preTrainGA	autoencoder.cpp	/^void autoencoder::preTrainGA(float **trainingImages, int numTrainingImages)$/;"	f	class:autoencoder
preTrainGAMiniBatch	autoencoder.cpp	/^void autoencoder::preTrainGAMiniBatch(float **trainingImages, int numTrainingImages)$/;"	f	class:autoencoder
predictFineNoHidden	autoencoder.cpp	/^int autoencoder::predictFineNoHidden(float *o_i)$/;"	f	class:autoencoder
reconstructImage	autoencoder.cpp	/^void autoencoder::reconstructImage(float **testingImages, int layer, int n)$/;"	f	class:autoencoder
setCorruptedO_i	autoencoder.cpp	/^void autoencoder::setCorruptedO_i(float **corrupted_o_i, float **o_i, int k, int numTrainingImages, int length)$/;"	f	class:autoencoder
setO_i	autoencoder.cpp	/^void autoencoder::setO_i(float **o_i, float **trainingImages, int k, int numTrainingImages, int length)$/;"	f	class:autoencoder
testFineNoHidden	autoencoder.cpp	/^void autoencoder::testFineNoHidden(float **testingImages, vector<int> &testLabels, int numTestingImages)$/;"	f	class:autoencoder
train	autoencoder.cpp	/^void autoencoder::train(float **trainingImages, vector<int> &trainLabels, int numOuterIter, int numTrainingImages)$/;"	f	class:autoencoder
uniformRandom	autoencoder.cpp	/^inline float uniformRandom()$/;"	f
visualizeWeights	autoencoder.cpp	/^void autoencoder::visualizeWeights(int layer, int n)$/;"	f	class:autoencoder
~autoencoder	autoencoder.cpp	/^autoencoder::~autoencoder()$/;"	f	class:autoencoder
AUTOENCODER	autoencoder.h	2;"	d
autoencoder	autoencoder.h	/^class autoencoder: public neural_network$/;"	c
numPreTrainLayers	autoencoder.h	/^  int numPreTrainLayers;$/;"	m	class:autoencoder
output_l	autoencoder.h	/^  hidden_layer *output_l;$/;"	m	class:autoencoder
preTrainLayers	autoencoder.h	/^  vector<auto_hidden_layer *> preTrainLayers;$/;"	m	class:autoencoder
preTrainLayersLearnRates	autoencoder.h	/^  vector<float> preTrainLayersLearnRates;$/;"	m	class:autoencoder
preTrainLayersNoiseLevels	autoencoder.h	/^  vector<float> preTrainLayersNoiseLevels;$/;"	m	class:autoencoder
preTrainLayersOuterIter	autoencoder.h	/^  vector<int> preTrainLayersOuterIter;$/;"	m	class:autoencoder
preTrainLayersOutputs	autoencoder.h	/^  vector<float *> preTrainLayersOutputs;$/;"	m	class:autoencoder
compareIndividual	ga.cpp	/^bool compareIndividual(individual a, individual b)$/;"	f
copyIndividual	ga.cpp	/^void genetic::copyIndividual(individual &a, individual &b)$/;"	f	class:genetic
crossOver	ga.cpp	/^void genetic::crossOver(individual &a, individual &b)$/;"	f	class:genetic
fitnessSelection	ga.cpp	/^int genetic::fitnessSelection()$/;"	f	class:genetic
genetic	ga.cpp	/^genetic::genetic(ga_params myParams):$/;"	f	class:genetic
getStats	ga.cpp	/^void genetic::getStats()$/;"	f	class:genetic
linearRanking	ga.cpp	/^void genetic::linearRanking()$/;"	f	class:genetic
mutate	ga.cpp	/^void genetic::mutate(individual &a)$/;"	f	class:genetic
noRanking	ga.cpp	/^void genetic::noRanking()$/;"	f	class:genetic
powerRanking	ga.cpp	/^void genetic::powerRanking()$/;"	f	class:genetic
randFloat	ga.cpp	/^inline float randFloat()$/;"	f
randRange	ga.cpp	/^inline float randRange(float Min, float Max)$/;"	f
s	ga.cpp	/^uint64_t s[2];$/;"	v
seed_xorshift128plus	ga.cpp	/^void seed_xorshift128plus(uint64_t s1, uint64_t s2)$/;"	f
step	ga.cpp	/^void genetic::step()$/;"	f	class:genetic
xorshift128plus	ga.cpp	/^uint64_t xorshift128plus()$/;"	f
~genetic	ga.cpp	/^genetic::~genetic()$/;"	f	class:genetic
GA	ga.h	2;"	d
age	ga.h	/^  int age;$/;"	m	struct:individual
alpha	ga.h	/^  float alpha;$/;"	m	struct:ga_params
bestIndIndex	ga.h	/^  int bestIndIndex;$/;"	m	class:genetic
chunkSize	ga.h	/^  int chunkSize;$/;"	m	struct:ga_params
crossRate	ga.h	/^  float crossRate;$/;"	m	struct:ga_params
deleteIndividual	ga.h	/^  inline void deleteIndividual(individual &a)$/;"	f	class:genetic
fitness	ga.h	/^  float fitness;$/;"	m	struct:individual
ga_params	ga.h	/^struct ga_params$/;"	s
genetic	ga.h	/^class genetic$/;"	c
genome	ga.h	/^  float *genome;$/;"	m	struct:individual
genomeSize	ga.h	/^  int genomeSize;$/;"	m	struct:ga_params
getGenome	ga.h	/^  inline float *getGenome(int i)$/;"	f	class:genetic
individual	ga.h	/^struct individual$/;"	s
initRange	ga.h	/^  float initRange;$/;"	m	struct:ga_params
maxFitness	ga.h	/^  float totalFitness, maxFitness, minFitness, meanFitness, totalScaledFitness;$/;"	m	class:genetic
meanFitness	ga.h	/^  float totalFitness, maxFitness, minFitness, meanFitness, totalScaledFitness;$/;"	m	class:genetic
minFitness	ga.h	/^  float totalFitness, maxFitness, minFitness, meanFitness, totalScaledFitness;$/;"	m	class:genetic
mutAmount	ga.h	/^  float mutAmount;$/;"	m	struct:ga_params
mutRate	ga.h	/^  float mutRate;$/;"	m	struct:ga_params
myDist	ga.h	/^  cauchy_distribution<float> myDist;$/;"	m	class:genetic
myEngine	ga.h	/^  mt19937_64 myEngine;$/;"	m	class:genetic
myParams	ga.h	/^  ga_params myParams;$/;"	m	class:genetic
normalBank	ga.h	/^  float *normalBank;$/;"	m	class:genetic
numEval	ga.h	/^  int numGen, numEval;$/;"	m	class:genetic
numGen	ga.h	/^  int numGen, numEval;$/;"	m	class:genetic
numToReplace	ga.h	/^  int numToReplace;$/;"	m	struct:ga_params
numWeights	ga.h	/^  int numWeights;$/;"	m	struct:ga_params
popSize	ga.h	/^  int popSize;$/;"	m	struct:ga_params
population	ga.h	/^  vector<individual> population;$/;"	m	class:genetic
printStats	ga.h	/^  inline void printStats()$/;"	f	class:genetic
randBank	ga.h	/^  float *randBank;$/;"	m	class:genetic
randBankSize	ga.h	/^  int randBankSize;$/;"	m	class:genetic
scaledFitness	ga.h	/^  float scaledFitness;$/;"	m	struct:individual
setFitness	ga.h	/^  inline void setFitness(int i, float fitness)$/;"	f	class:genetic
totalFitness	ga.h	/^  float totalFitness, maxFitness, minFitness, meanFitness, totalScaledFitness;$/;"	m	class:genetic
totalScaledFitness	ga.h	/^  float totalFitness, maxFitness, minFitness, meanFitness, totalScaledFitness;$/;"	m	class:genetic
compute_delta_hidden	hidden_layer.cpp	/^void hidden_layer::compute_delta_hidden(float *delta_curr_layer, float *delta_next_layer, float *output_curr_layer, hidden_layer *next_layer)$/;"	f	class:hidden_layer
compute_delta_output	hidden_layer.cpp	/^void hidden_layer::compute_delta_output(float *delta, float *o, int t)$/;"	f	class:hidden_layer
encode	hidden_layer.cpp	/^void hidden_layer::encode(float *input, float *output)$/;"	f	class:hidden_layer
hidden_layer	hidden_layer.cpp	/^hidden_layer::hidden_layer(int numInputs, int numHiddenUnits):$/;"	f	class:hidden_layer
hidden_layer	hidden_layer.cpp	/^hidden_layer::hidden_layer(int numInputs, int numHiddenUnits, float weightRange):$/;"	f	class:hidden_layer
init	hidden_layer.cpp	/^void hidden_layer::init()$/;"	f	class:hidden_layer
printWeights	hidden_layer.cpp	/^void hidden_layer::printWeights(int n)$/;"	f	class:hidden_layer
sigmoidTransform	hidden_layer.cpp	/^void hidden_layer::sigmoidTransform(float *x)$/;"	f	class:hidden_layer
squared_loss	hidden_layer.cpp	/^float hidden_layer::squared_loss(float *output, int t)$/;"	f	class:hidden_layer
updateWeights	hidden_layer.cpp	/^void hidden_layer::updateWeights(float *delta_curr_layer, float *output_prev_layer, float learn_rate)$/;"	f	class:hidden_layer
~hidden_layer	hidden_layer.cpp	/^hidden_layer::~hidden_layer()$/;"	f	class:hidden_layer
HIDDEN_LAYER	hidden_layer.h	2;"	d
RandomNumber	hidden_layer.h	/^  inline float RandomNumber(float Min, float Max)$/;"	f	class:hidden_layer
__t	hidden_layer.h	/^  float *weights, *biases, *__t;$/;"	m	class:hidden_layer
biases	hidden_layer.h	/^  float *weights, *biases, *__t;$/;"	m	class:hidden_layer
getEncodeBiases	hidden_layer.h	/^  inline float *getEncodeBiases()$/;"	f	class:hidden_layer
getNumHiddenUnits	hidden_layer.h	/^  inline int getNumHiddenUnits()$/;"	f	class:hidden_layer
getNumInputUnits	hidden_layer.h	/^  inline int getNumInputUnits()$/;"	f	class:hidden_layer
getNumWeights	hidden_layer.h	/^  inline int getNumWeights()$/;"	f	class:hidden_layer
getWeightRange	hidden_layer.h	/^  inline float getWeightRange()$/;"	f	class:hidden_layer
getWeights	hidden_layer.h	/^  inline float *getWeights()$/;"	f	class:hidden_layer
hiddenChunkSize	hidden_layer.h	/^  int numInputs, numHiddenUnits, numWeights, hiddenChunkSize, inputChunkSize;$/;"	m	class:hidden_layer
hidden_layer	hidden_layer.h	/^class hidden_layer$/;"	c
inputChunkSize	hidden_layer.h	/^  int numInputs, numHiddenUnits, numWeights, hiddenChunkSize, inputChunkSize;$/;"	m	class:hidden_layer
numHiddenUnits	hidden_layer.h	/^  int numInputs, numHiddenUnits, numWeights, hiddenChunkSize, inputChunkSize;$/;"	m	class:hidden_layer
numInputs	hidden_layer.h	/^  int numInputs, numHiddenUnits, numWeights, hiddenChunkSize, inputChunkSize;$/;"	m	class:hidden_layer
numWeights	hidden_layer.h	/^  int numInputs, numHiddenUnits, numWeights, hiddenChunkSize, inputChunkSize;$/;"	m	class:hidden_layer
setChunkSize	hidden_layer.h	/^  inline void setChunkSize(int x)$/;"	f	class:hidden_layer
setEncodeBiases	hidden_layer.h	/^  inline void setEncodeBiases(float *newBiases)$/;"	f	class:hidden_layer
setWeights	hidden_layer.h	/^  inline void setWeights(float *newWeights)$/;"	f	class:hidden_layer
sigmoidTransform	hidden_layer.h	/^  inline float sigmoidTransform(float x)$/;"	f	class:hidden_layer
weightRange	hidden_layer.h	/^  float weightRange;$/;"	m	class:hidden_layer
weights	hidden_layer.h	/^  float *weights, *biases, *__t;$/;"	m	class:hidden_layer
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
experiment_1	main.cpp	/^void experiment_1(vector<int> &trainLabels, float **trainingImages)$/;"	f
experiment_2	main.cpp	/^void experiment_2(vector<int> &trainLabels, float **trainingImages)$/;"	f
experiment_3	main.cpp	/^void experiment_3(vector<int> &trainLabels, float **trainingImages, vector<int> &testLabels, float **testingImages)$/;"	f
main	main.cpp	/^int main(int argc, char *argv[])$/;"	f
numTestingImages	main.cpp	/^int numTestingImages;$/;"	v
numTrainingImages	main.cpp	/^int numTrainingImages;$/;"	v
parseImages	main.cpp	/^void parseImages(vector<vector<vector<float> > > &__images, float **images, int numImages)$/;"	f
train_and_test_autoencoder	main.cpp	/^void train_and_test_autoencoder(vector<int> &trainLabels, float **trainingImages, vector<int> &testLabels, float **testingImages)$/;"	f
train_and_test_autoencoderGA	main.cpp	/^void train_and_test_autoencoderGA(vector<int> &trainLabels, float **trainingImages, vector<int> &testLabels, float **testingImages)$/;"	f
train_and_test_network_cross	main.cpp	/^void train_and_test_network_cross(int numOuterIter, vector<int> &trainLabels, float **trainingImages, vector<int> &testLabels, float **testingImages)$/;"	f
train_and_test_network_square	main.cpp	/^void train_and_test_network_square(int numOuterIter, vector<int> &trainLabels, float **trainingImages, vector<int> &testLabels, float **testingImages)$/;"	f
MNIST_READER_HPP	mnist/include/mnist_reader.hpp	9;"	d
MNIST_dataset	mnist/include/mnist_reader.hpp	/^struct MNIST_dataset {$/;"	s	namespace:mnist
mnist	mnist/include/mnist_reader.hpp	/^namespace mnist {$/;"	n
read_header	mnist/include/mnist_reader.hpp	/^inline uint32_t read_header(const std::unique_ptr<char[]>& buffer, size_t position){$/;"	f	namespace:mnist
read_mnist_image_file	mnist/include/mnist_reader.hpp	/^Container<Sub<Pixel>> read_mnist_image_file(const std::string& path, std::size_t limit = 0){$/;"	f	namespace:mnist
read_mnist_image_file_sq	mnist/include/mnist_reader.hpp	/^Container<Sub<Sub<Pixel>>> read_mnist_image_file_sq(const std::string& path, std::size_t limit = 0){$/;"	f	namespace:mnist
read_mnist_label_file	mnist/include/mnist_reader.hpp	/^Container<Label> read_mnist_label_file(const std::string& path, std::size_t limit = 0){$/;"	f	namespace:mnist
resize_test	mnist/include/mnist_reader.hpp	/^    void resize_test(std::size_t new_size){$/;"	f	struct:mnist::MNIST_dataset
resize_training	mnist/include/mnist_reader.hpp	/^    void resize_training(std::size_t new_size){$/;"	f	struct:mnist::MNIST_dataset
test_images	mnist/include/mnist_reader.hpp	/^    Container<Sub<Pixel>> test_images;$/;"	m	struct:mnist::MNIST_dataset
test_labels	mnist/include/mnist_reader.hpp	/^    Container<Label> test_labels;$/;"	m	struct:mnist::MNIST_dataset
training_images	mnist/include/mnist_reader.hpp	/^    Container<Sub<Pixel>> training_images;$/;"	m	struct:mnist::MNIST_dataset
training_labels	mnist/include/mnist_reader.hpp	/^    Container<Label> training_labels;$/;"	m	struct:mnist::MNIST_dataset
MNIST_READER_HPP	mnist/include/mnist_reader_less.hpp	9;"	d
MNIST_dataset	mnist/include/mnist_reader_less.hpp	/^struct MNIST_dataset {$/;"	s	namespace:mnist
mnist	mnist/include/mnist_reader_less.hpp	/^namespace mnist {$/;"	n
read_header	mnist/include/mnist_reader_less.hpp	/^inline uint32_t read_header(const std::unique_ptr<char[]>& buffer, size_t position){$/;"	f	namespace:mnist
read_mnist_image_file	mnist/include/mnist_reader_less.hpp	/^std::vector<std::vector<Pixel>> read_mnist_image_file(const std::string& path){$/;"	f	namespace:mnist
read_mnist_image_file_sq	mnist/include/mnist_reader_less.hpp	/^std::vector<std::vector<std::vector<Pixel>>> read_mnist_image_file_sq(const std::string& path){$/;"	f	namespace:mnist
read_mnist_label_file	mnist/include/mnist_reader_less.hpp	/^std::vector<Label> read_mnist_label_file(const std::string& path){$/;"	f	namespace:mnist
test_images	mnist/include/mnist_reader_less.hpp	/^    std::vector<std::vector<Pixel>> test_images;$/;"	m	struct:mnist::MNIST_dataset
test_labels	mnist/include/mnist_reader_less.hpp	/^    std::vector<Label> test_labels;$/;"	m	struct:mnist::MNIST_dataset
training_images	mnist/include/mnist_reader_less.hpp	/^    std::vector<std::vector<Pixel>> training_images;$/;"	m	struct:mnist::MNIST_dataset
training_labels	mnist/include/mnist_reader_less.hpp	/^    std::vector<Label> training_labels;$/;"	m	struct:mnist::MNIST_dataset
MNIST_UTILS_HPP	mnist/include/mnist_utils.hpp	9;"	d
binarize_dataset	mnist/include/mnist_utils.hpp	/^void binarize_dataset(Dataset& dataset){$/;"	f	namespace:mnist
binarize_each	mnist/include/mnist_utils.hpp	/^void binarize_each(Container& values, double threshold = 30.0){$/;"	f	namespace:mnist
mean	mnist/include/mnist_utils.hpp	/^double mean(const Container& container){$/;"	f	namespace:mnist
mnist	mnist/include/mnist_utils.hpp	/^namespace mnist {$/;"	n
normalize_dataset	mnist/include/mnist_utils.hpp	/^void normalize_dataset(Dataset& dataset){$/;"	f	namespace:mnist
normalize_each	mnist/include/mnist_utils.hpp	/^void normalize_each(Container& values){$/;"	f	namespace:mnist
stddev	mnist/include/mnist_utils.hpp	/^double stddev(const Container& container, double mean){$/;"	f	namespace:mnist
backprop	neural_network.cpp	/^float neural_network::backprop(float *o_i, int t)$/;"	f	class:neural_network
neural_network	neural_network.cpp	/^neural_network::neural_network(int numInput, int numHidden, int numOutput, float learn_rate):$/;"	f	class:neural_network
predict	neural_network.cpp	/^int neural_network::predict(float *o_i)$/;"	f	class:neural_network
test	neural_network.cpp	/^void neural_network::test(float **testingImages, vector<int> &testLabels, int numTestingImages)$/;"	f	class:neural_network
train	neural_network.cpp	/^void neural_network::train(float **trainingImages, vector<int> &trainLabels, int numOuterIter, int numTrainingImages)$/;"	f	class:neural_network
~neural_network	neural_network.cpp	/^neural_network::~neural_network()$/;"	f	class:neural_network
NEURAL_NETWORK	neural_network.h	2;"	d
delta_j	neural_network.h	/^  float *o_j, *o_k, *delta_k, *delta_j;$/;"	m	class:neural_network
delta_k	neural_network.h	/^  float *o_j, *o_k, *delta_k, *delta_j;$/;"	m	class:neural_network
getInput	neural_network.h	/^  virtual void getInput(float *&o_i) {};$/;"	f	class:neural_network
h	neural_network.h	/^  hidden_layer *h, *o;$/;"	m	class:neural_network
learn_rate	neural_network.h	/^  float learn_rate, prevTrainError;$/;"	m	class:neural_network
neural_network	neural_network.h	/^class neural_network$/;"	c
o	neural_network.h	/^  hidden_layer *h, *o;$/;"	m	class:neural_network
o_j	neural_network.h	/^  float *o_j, *o_k, *delta_k, *delta_j;$/;"	m	class:neural_network
o_k	neural_network.h	/^  float *o_j, *o_k, *delta_k, *delta_j;$/;"	m	class:neural_network
prevTrainError	neural_network.h	/^  float learn_rate, prevTrainError;$/;"	m	class:neural_network
backprop	neural_network_cross.cpp	/^float neural_network_cross::backprop(float *o_i, int t)$/;"	f	class:neural_network_cross
neural_network_cross	neural_network_cross.cpp	/^neural_network_cross::neural_network_cross(int numInput, int numHidden, int numOutput, float learn_rate):$/;"	f	class:neural_network_cross
predict	neural_network_cross.cpp	/^int neural_network_cross::predict(float *o_i)$/;"	f	class:neural_network_cross
~neural_network_cross	neural_network_cross.cpp	/^neural_network_cross::~neural_network_cross()$/;"	f	class:neural_network_cross
NEURAL_NETWORK_CROSS	neural_network_cross.h	2;"	d
delta_j	neural_network_cross.h	/^  float *o_j, *o_k, *delta_k, *delta_j;$/;"	m	class:neural_network_cross
delta_k	neural_network_cross.h	/^  float *o_j, *o_k, *delta_k, *delta_j;$/;"	m	class:neural_network_cross
h	neural_network_cross.h	/^	hidden_layer *h;$/;"	m	class:neural_network_cross
learn_rate	neural_network_cross.h	/^  float learn_rate;$/;"	m	class:neural_network_cross
neural_network_cross	neural_network_cross.h	/^class neural_network_cross$/;"	c
o	neural_network_cross.h	/^	output_layer *o;$/;"	m	class:neural_network_cross
o_j	neural_network_cross.h	/^  float *o_j, *o_k, *delta_k, *delta_j;$/;"	m	class:neural_network_cross
o_k	neural_network_cross.h	/^  float *o_j, *o_k, *delta_k, *delta_j;$/;"	m	class:neural_network_cross
compute_delta_output	output_layer.cpp	/^void output_layer::compute_delta_output(float *delta, float *o, int t)$/;"	f	class:output_layer
cross_entropy_loss	output_layer.cpp	/^float output_layer::cross_entropy_loss(float *output, int t)$/;"	f	class:output_layer
encode	output_layer.cpp	/^void output_layer::encode(float *input, float *output)$/;"	f	class:output_layer
softMaxTransform	output_layer.cpp	/^void output_layer::softMaxTransform(float *x)$/;"	f	class:output_layer
OUTPUT_LAYER	output_layer.h	2;"	d
output_layer	output_layer.h	/^  output_layer(int numInputs, int numHiddenUnits) : hidden_layer(numInputs, numHiddenUnits) {}$/;"	f	class:output_layer
output_layer	output_layer.h	/^  output_layer(int numInputs, int numHiddenUnits, float weightRangs) : hidden_layer(numInputs, numHiddenUnits, weightRange) {}$/;"	f	class:output_layer
output_layer	output_layer.h	/^class output_layer: public hidden_layer$/;"	c
